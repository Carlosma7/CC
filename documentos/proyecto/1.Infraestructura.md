# Hito 1: Concretando y planificando el proyecto

## Objetivo

Se trata de *definir un proyecto* entre las diferentes posibilidades
que se planteen, explicar *su arquitectura* y *organizar los hitos*
para el trabajo en el mismo, así como avanzar en lo posible en el
*interfaz* y *estructuras de datos* de la clases iniciales que se
vayan a implementar.

Lo esencial es entender cuál es la
arquitectura y la entidad de lo que se despliega en la nube y quién va
a ser el *cliente* del mismo (uno mismo, alguna empresa con la que se
haya contactado, el tutor o tutora del TFM), especificando los
diferentes roles que va a haber y lo que buscan (en la solución del
problema) en las denominadas *historias de usuario* (o HU).

## Prerrequisitos

Haber alcanzado los objetivos de las sesiones correspondientes de la
asignatura (semanas uno a tres). Como es habitual, se tendrán que
entregar los objetivos previamente, en un PR separado, y con una
antelación de al menos dos horas.

## Explicación

Una vez que en [el hito 0](0.Repositorio) el MVP creado es simplemente
la descripción de un problema que se va a resolver, en este hito el
MVP será la planificación del proyecto a grandes rasgos, así como
comenzar a especificar una serie de *historias de usuario* que
describan qué es lo que diferentes roles (tales como usuario,
administrador, otro...) van a necesitar del proyecto.

Supongamos que queremos resolver el proyecto de listas de la compra
compartidas para una familia. Las siguientes historias de usuario
serían posibles:

* [HU1] Como *miembro de la familia* (rol), necesito poder añadir
      (actividad) productos (datos) a la lista de la compra.

Pero también la siguiente:

* [HU2] Como *administrador de la aplicación*, necesito analizar
  (actividad) la evolución de los productos comprados sobre la línea
  temporal (datos).

En general, hay que entender bien de qué se trata el problema y hacer
un número de historias que nos lleven a una solución posible del
mismo, y que sea desplegable en la nube.

La planificación del resto del proyecto es la esencia
de este hito, es decir, tras haber creado en el hito anterior una
descripción general de la arquitectura y de las piezas del proyecto,
en este tendréis que crear las *historias de usuario* en un *issue* y
esos issues tendrán que estar, si no completos, al menos de una forma
bastante completa en este hito. Como se ve, las historias de usuario
son de alto nivel, y en general harán falta issues adicionales para
que se llegue a un nivel en el que se pueda crear código y comprobar
si ese código lleva a cabo la tarea propuesta.

Se recuerda que hay que seguir las recomendaciones presentadas en
el [el hito 0](0.Repositorio) sobre commits, issues y milestones.

Adicionalmente, el estudiante puede comenzar a programar estas
clases. Como todavía no hemos llegado a un punto en el que se pueda
testear el código, sólo se puede crear el "cascarón" de la clase, en
el que debe de estar completa

* La estructura de datos que vaya a implementar una historia de
  usuario.
* El interfaz de la clase (métodos y funciones con argumentos que
  tendrán el tipo y número adecuado, pero sin ninguna funcionalidad ni
  lógica de negocio).

Estos "cascarones" tendrán que ser sintácticamente correctos, y sobre
todo estar ligados de la forma que se indicó en el hito 0 a las
historias de usuario correspondientes y que se hayan comenzado a
implementar en ellos.

### En el principio, son las historias de usuario.

Las historias de usuario son imprescindibles para definir, de forma
precisa y exhaustiva, el funcionamiento de una aplicación. Estas
historias de usuario tienen que definir

* Los roles dentro de la aplicación. Esos roles pueden corresponder, o
  no, a clases dentro de la aplicación (por ejemplo, puede haber un
  rol de *product owner* que sea el que establece cierta configuración
  inicial y asigna, por ejemplo, roles a usuarios o simplemente
  establece los valores iniciales de algo), pero en todo caso tiene
  que estar bien claro quién puede hacer qué y quién quiere hacer
  qué. Como los roles se usan en todas las HU, las primeras HU deben
  ir siempre encaminadas a establecer estos roles. En ese sentido, hay
  metodologías específicas,
  como
  [las mencionadas aquí](https://jj.github.io/curso-tdd/temas/dise%C3%B1o.html),
  que deciden qué son esos roles y cómo se pueden establecer
  diferencias entre los mismos.
* A continuación tiene que haber HUs que establezcan las diferentes
  entidades y objetos valor que se van a usar; una vez más,
  consultar
  [este tema](https://jj.github.io/curso-tdd/temas/dise%C3%B1o.html) o
  simplemente
  el [primer capítulo](../temas/Arquitecturas_para_la_nube.md) donde
  hay diferentes enlaces. En principio, en este hito no se requiere
  mucho más, porque únicamente hace falta definir y crear el interfaz
  de estas entidades.
* Esas HUs tienen que establecer las relaciones entre entidades, y de
  ahí tiene que salir qué son entidades, qué son agregados, y qué son
  objetos valor. Los agregados contienen otras entidads y objetos
  valor, y son imprescindibles a la hora de diseñar una aplicación.
* El resto de las HUs tendrá que definir la lógica de negocio, y
  *tiene que haber una lógica de negocio*, un procesamiento de datos
  que vaya más allá del ciclo CRUD.

### Hay que teneer un plan.

Las HUs no secuencian, ni dicen cómo se van a agrupar, pero lo más
importante es que no hacen ningún "empaquetado" ni deciden qué se va a
"pasar a producción". En general, "pasar a producción" es algo que se
va a enseñar al cliente; en esta asignatura el cliente es el profesor
(y uno mismo, claro); eso quiere decir que lo que se "pase a
producción" corresponderá, en general, a lo que se va a entregar en un
hito, por ejemplo, en este.

Los hitos se tienen que organizar para que en cada hito se pase a
producción algo. La secuencia de hitos tendrá que, en cada caso,
construir un hito a partir del siguiente si hay interdependencia
(normalmente la habrá), o simplemente junto al siguiente para
posteriormente integrarlos en un producto mínimamente viable.

Un hito es, por tanto, equivalente a un producto mínimamente viable,
pero evidentemente hay que especificar *cuál* es ese producto
mínimamente viable que se va a "pasar a producción". En este caso se
pide (y para crédito adicional) una entidad o entidades; ese será por
tanto el MVP *en este caso*.

Pero el plan, que se deberá ir actualizando durante la asignatura,
incluye éste y cuales van a ser los próximos hitos/MVP que se van a ir
entregando, y una vez más, un MVP es un MVP, no "tres funciones de
esta clase". Es un *algo* que hace *algo*.

Hay muchas estrategias para llevar estos planes a cabo; pueden
desarrollarse de forma horizontal (en el primer hito identifico
*todas* las entidades que voy a usar y defino su API) o vertical
(defino de forma estricta una sola entidad, que a continuación voy a
seguir desarrollando en el segundo hito, donde además, voy a empezar a
desarrollar una segunda entidad que necesita la primera).

Lo que tiene que quedar meridianamente claro es que los hitos marcan
un punto de control. Dentro de un hito no se pueden usar los productos
del mismo hito; hasta que no se termine un hito no se puede pasar al
siguiente.

Pero esa organización de hitos es, en principio, ortogonal a las
HUs. Normalmente las HUs hablan de usuarios finales, lo que, salvo que
nuestro producto final sea un backend completo y lo definamos de esa
forma, no vamos a alcanzar en esta asignatura. Así que los hitos no
van a incluir en realidad HUs (salvo excepciones), sino tareas dentro
de cada HU, que, para aclarar, deberían ser issues independientes
dentro de la HU. Las HU se pueden mantener fuera de los hitos, o bien
irse moviendo de un hito al siguiente cuando las tareas que se vayan a
realizar continúen en el hito siguiente.

### El código importa



## Información adicional

Se pueden consultar los siguientes temas
del [curso 0](https://jj.github.io/curso-tdd):

* El amplio panorama de
  [aplicaciones que se pueden diseñar para resolver problemas](https://jj.github.io/curso-tdd/temas/aplicaciones.html)
* Diferentes
  [servicios](https://jj.github.io/curso-tdd/temas/servicios.html) de
  uso habitual en despliegues en la nube
* Cómo especificar
  los
  [requisitos](https://jj.github.io/curso-tdd/temas/dise%C3%B1o.html)
  y qué hacer para diseñar los primeros pasos de una aplicación, es
  decir, qué hay que hacer para crear buenas historias de usuario y
  cómo extraer, a partir de ellas, la entidad principal o principales
  entidades a partir de las cuales se va a empezar a trabajar.
* Cómo
  implementar
  [clases abstractas](https://jj.github.io/curso-tdd/temas/a-programar.html) o
  definir los interfaces de clase antes de implementar.

## Entrega de la práctica

De la forma
habitual,
[editando el fichero con un enlace al repo](https://github.com/JJ/CC-20-21/blob/master/proyectos/1.md)
y un número de versión que se incrementará con cada hito y también con
cada envío adicional. Como este es el hito 1, la versión *major* de
la entrega corresponderá a este número.

En cada hito, el estado del README no debe de incluir "capas" donde se
incluyan todos los hitos anteriores, sino que tiene que estar adaptado
a la realidad de cada hito, es decir, ir directamente al grano. Lo que
se haya incluido en hitos anteriores y que ya no sea relevante se
puede enlazar donde corresponda, tras moverse (preferiblemente) a un
fichero específico.

En concreto, se enviarán y testearán los siguientes aspectos en este
hito:

* El README tendrá que describir la arquitectura que va a seguir el
  proyecto, entre las descritas en
  el [primer capítulo](../temas/Arquitecturas_para_la_nube.md).
* Hitos en número suficiente para cubrir el desarrollo del proyecto
  que se vaya a hacer durante esta asignatura.
* Historias de usuario que tengan `HU` o `US` (como en `user stories`)
  en la descripción y la etiqueta `user-stories`, en número suficiente
  para poder trabajar en este hito y algunos de los siguientes.
* Para crédito adicional, la clase o clases que se hayan comenzado a
  implementar (sin código) correspondientes a las historias de
  usuario. Para indicar qué clases son estas, se usará un fichero
  `cc.yaml`, y, en la clave `entidad`, el fichero donde se haya
  programado la entidad en forma de una clase, módulo o paquete que es
  el objeto de este hito, con el camino correcto, por ejemplo

```yaml
entidad: src/Recordatorio.js
```

Tras la primera corrección, para reenviar hay que seguir las
siguientes
[instrucciones](https://jj.github.io/CC/documentos/proyecto/Reenvios).

## Valoración

1. 3 puntos: Descripción correcta y justificada de la arquitectura,
  herramientas y demás elementos
  del [primer capítulo](../temas/Arquitecturas_para_la_nube.md).
2. 4 puntos: Uso correcto de hitos, historias de usuario e *issues*, es
  decir, issues que reflejen historias de usuario (en su mayoría,
  puede haber subtareas de cada historia de usuario), agrupados en un
  *roadmap* o plan de desarrollo que abarcará el resto de la
  asignatura (o gran parte del mismo). Estas historias de usuario
  tendrán que intentar, en lo posible, ser específicas de la
  arquitectura que se haya descrito en la rúbrica 1, o de alguna
  forma, como se explicó en clase el día 13, se debe ver que la
  arquitectura que se ha elegido es la adecuada.

3. 2 puntos: creación de una clase o clases, avanzando el proyecto en
  las HU

4. 1 puntos: concedidos por originalidad de la aplicación, grado de
  terminación, utilidad para la asignatura, cantidad de trabajo
  invertido.

Si el repositorio no existe, tiene algún error, no se ha hecho *pull
request* correctamente o hay alguna evidencia de plagio, *la práctica
estará suspensa*.
